<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Advent of Code 2021]]></title><description><![CDATA[My attempt to the Advent of Code of 2021]]></description><link>triozer.github.io/aoc-2021-in-kotlin/</link><image><url>triozer.github.io/aoc-2021-in-kotlin/favicon.png</url><title>Advent of Code 2021</title><link>triozer.github.io/aoc-2021-in-kotlin/</link></image><generator>Ghost 4.25</generator><lastBuildDate>Thu, 02 Dec 2021 16:11:01 GMT</lastBuildDate><atom:link href="triozer.github.io/aoc-2021-in-kotlin/blog/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Day 2. Dive!]]></title><description><![CDATA[<p> </p>]]></description><link>triozer.github.io/aoc-2021-in-kotlin/blog/day-2/</link><guid isPermaLink="false">61a8b2c8fd83d81ffe3fe7a2</guid><dc:creator><![CDATA[Cédric Boirard]]></dc:creator><pubDate>Thu, 02 Dec 2021 11:49:30 GMT</pubDate><content:encoded><![CDATA[<p> </p>]]></content:encoded></item><item><title><![CDATA[Day 1. Sonar Sweep]]></title><description><![CDATA[<h2 id="part-1"><a href="https://adventofcode.com/2021/day/1">Part 1</a></h2><h3 id="problem">Problem</h3><p>In this first part, we are talking about counting the number of times a depth measurement increases from the previous measurement.</p><p>First, we will have to parse the list of received measurements and transform it into an array of integers. To do this feel free to look</p>]]></description><link>triozer.github.io/aoc-2021-in-kotlin/blog/day-1/</link><guid isPermaLink="false">61a8b1ddfd83d81ffe3fe79c</guid><category><![CDATA[stdlib]]></category><dc:creator><![CDATA[Cédric Boirard]]></dc:creator><pubDate>Thu, 02 Dec 2021 11:45:35 GMT</pubDate><content:encoded><![CDATA[<h2 id="part-1"><a href="https://adventofcode.com/2021/day/1">Part 1</a></h2><h3 id="problem">Problem</h3><p>In this first part, we are talking about counting the number of times a depth measurement increases from the previous measurement.</p><p>First, we will have to parse the list of received measurements and transform it into an array of integers. To do this feel free to look at how it is done in the <code><a href="https://github.com/triozer/aoc-2021-in-kotlin/blob/7a8f7674983b3c07a8777bd274592a0ef5d1390b/src/main/kotlin/fr/triozer/aoc/Utils.kt#L15"><em>Utils.kt</em></a></code> file.</p><p>Then, we use the <code><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/zip-with-next.html">zipWithNext</a></code> function whose role is to pair the elements of our list. Let&apos;s take the example proposed for today:</p><pre><code>[199, 200, 208, ..., 269, 260, 263]</code></pre><p>After calling the function, we get:</p><pre><code>[
    [199, 200],
    [200, 208],
    ...
    [269, 260],
    [260, 263]
]</code></pre><p>Finally, we need to count how many of them match the criterion (a measure of depth increases from the previous measure) using the <code><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/count.html#count">count</a></code> function. The count function takes a predicate and if it returns true, the counter is incremented. In our case, we compare if the second element of the pair is greater than the first element of the pair.</p><h3 id="solution">Solution</h3><pre><code class="language-kt">fun part1(input: List&lt;Int&gt;) = input.zipWithNext().count {
    (next, previous) -&gt; next &gt; previous
}</code></pre><h2 id="part-2"><a href="https://adventofcode.com/2021/day/2">Part 2</a></h2><h3 id="problem-1">Problem</h3><p>The second part is really similar to the first one, except that instead of taking the values one by one, we group them by three.</p><p>For that, we can call the <code><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/windowed.html">windowed</a></code> function which create a sliding windowof a given size. Let&apos;s take the example proposed for today:</p><pre><code>[199, 200, 208, 210, ..., 240, 269, 260, 263]</code></pre><p>After calling the function, we get:</p><pre><code>[
    [199, 200, 208],
    [200, 208, 210],
    ...
    [240, 269, 260],
    [269, 260, 263]
]</code></pre><p>Now we want to sum each new list, fortunately Kotlin have a <code><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sum.html">sum</a></code> method that can called on iterators. So from the previous list, we now have:</p><pre><code>[
    607,
    618,
    ...
    769,
    792
]</code></pre><p>And that&apos;s awesome because we can reuse our previous function to count how many groups of measures increase from the previous group of measures.</p><h3 id="solution-1">Solution</h3><pre><code class="language-kt">fun part2(input: List&lt;Int&gt;) = part1(input.windowed(3) { it.sum() })</code></pre><h2 id="conclusion">Conclusion</h2><p>It was a great first puzzle! Besides being easy to understand, it reminded me how complete the standard Kotlin library was (in addition to being a great language).<br><br>+ 2 &#x2B50;&#xFE0F; !!! </p><h2 id="useful-links">Useful links</h2><ul><li><a href="triozer.github.io/aoc-2021-in-kotlin/introduction">Introduction</a> &#x2013; The introduction of this project.</li><li><a href="https://kotlinlang.org">https://kotlinlang.org</a> &#x2013; Kotlin official website.</li><li><a href="https://github.com/triozer/aoc-2021-in-kotlin">https://github.com/triozer/aoc-2021-in-kotlin</a> &#x2013; My solutions and tests for each day.</li></ul>]]></content:encoded></item></channel></rss>