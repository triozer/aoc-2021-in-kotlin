<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Advent of Code 2021]]></title><description><![CDATA[My attempt to the Advent of Code of 2021.]]></description><link>https://triozer.github.io/aoc-2021-in-kotlin/</link><image><url>https://triozer.github.io/aoc-2021-in-kotlin/favicon.png</url><title>Advent of Code 2021</title><link>https://triozer.github.io/aoc-2021-in-kotlin/</link></image><generator>Ghost 4.25</generator><lastBuildDate>Fri, 03 Dec 2021 10:12:24 GMT</lastBuildDate><atom:link href="https://triozer.github.io/aoc-2021-in-kotlin/blog/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Day 2. Dive!]]></title><description><![CDATA[<h2 id="introduction">Introduction</h2><p>Today&apos;s have a ton of possible solutions! Let&apos;s watch two ways in this post. The first one will be &quot;the logical&quot; way while the second will be more focused on Kotlin and functional programming.</p><h3 id="problem-input">Problem Input</h3><p>Now our submarine can take the following</p>]]></description><link>https://triozer.github.io/aoc-2021-in-kotlin/blog/day-2/</link><guid isPermaLink="false">61a95c7554e62874979e3f11</guid><dc:creator><![CDATA[Cédric Boirard]]></dc:creator><pubDate>Thu, 02 Dec 2021 22:59:00 GMT</pubDate><content:encoded><![CDATA[<h2 id="introduction">Introduction</h2><p>Today&apos;s have a ton of possible solutions! Let&apos;s watch two ways in this post. The first one will be &quot;the logical&quot; way while the second will be more focused on Kotlin and functional programming.</p><h3 id="problem-input">Problem Input</h3><p>Now our submarine can take the following commands <code>forward</code>, <code>down</code>, <code>up</code>.</p><p>First, we will have to parse the list of received commands. To do this feel free to look at how it is done in the <code><a href="https://github.com/triozer/aoc-2021-in-kotlin/blob/7a8f7674983b3c07a8777bd274592a0ef5d1390b/src/main/kotlin/fr/triozer/aoc/Utils.kt#L15"><em><a href="https://github.com/triozer/aoc-2021-in-kotlin/blob/91a492fda83cabb79be2c2c503bb70329365989e/src/main/kotlin/fr/triozer/aoc/Utils.kt#L10">Utils.kt</a></em></a></code> file.</p><!--kg-card-begin: markdown--><h1 id="version-1">Version 1</h1>
<!--kg-card-end: markdown--><h2 id="part-1"><a href="https://adventofcode.com/2021/day/1">Part 1</a> </h2><h3 id="problem">Problem</h3><p>Here the code is kinda straight forward. There is no much to explain. Maybe we can talk about array using destructing.</p><p>So, in Kotlin (as in JavaScript, Python...), we can easily destructuring an array / object. Given we have the following array <code>arr = [1, 2, 3]</code>, if we want to access these values, we should use their indexes:</p><pre><code class="language-kt">val arr = [1, 2, 3]

val a = arr[0]
val b = arr[1]
val c = arr[2]</code></pre><p>Whereas using destructuration, we can have:</p><pre><code class="language-kt">val (a, b, c) = [1, 2, 3]</code></pre><p>This is exactly what I&apos;ve done for splitting the command and it&apos;s value.</p><h3 id="solution">Solution</h3><pre><code class="language-kt">fun part1(input: List&lt;String&gt;): Int {
    var height = 0
    var depth = 0

    for (line in input) {
        val (command, step) = line.split(&quot; &quot;)
        when (command) {
            &quot;forward&quot; -&gt; height += step.toInt()
            &quot;down&quot; -&gt; depth += step.toInt()
            &quot;up&quot; -&gt; depth -= step.toInt()
        }
    }

    return height * depth
}</code></pre><h2 id="part-2"><a href="https://adventofcode.com/2021/day/2">Part 2</a></h2><h3 id="problem-1">Problem</h3><p>The second part only add a new variable, but the main &quot;logic&quot; is still the same.</p><h3 id="solution-1">Solution</h3><pre><code class="language-kt">fun part2(input: List&lt;String&gt;): Int {
    var height = 0
    var depth = 0
    var aim = 0

    for (line in input) {
        val (command, step) = line.split(&quot; &quot;)
        when (command) {
            &quot;forward&quot; -&gt; {
                height += step.toInt()
                depth += aim * step.toInt()
            }
            &quot;down&quot; -&gt; aim += step.toInt()
            &quot;up&quot; -&gt; aim -= step.toInt()
        }
    }

    return height * depth
}</code></pre><h2 id="conclusion">Conclusion</h2><p>An easy one, still nice to remember about object / array destructuring.</p><p><br>+ 2 &#x2B50;&#xFE0F; !!!</p><h2 id="useful-links">Useful links</h2><ul><li><a href="https://triozer.github.io/aoc-2021-in-kotlin/introduction.html">Introduction</a> &#x2013; The introduction of this project.</li><li><a href="https://kotlinlang.org/">https://kotlinlang.org</a> &#x2013; Kotlin official website.</li><li><a href="https://github.com/triozer/aoc-2021-in-kotlin">https://github.com/triozer/aoc-2021-in-kotlin</a> &#x2013; My solutions and tests for each day.</li></ul><p><br></p>]]></content:encoded></item><item><title><![CDATA[Day 1. Sonar Sweep]]></title><description><![CDATA[<h2 id="part-1"><a href="https://adventofcode.com/2021/day/1">Part 1</a></h2><h3 id="problem">Problem</h3><p>In this first part, we are talking about counting the number of times a depth measurement increases from the previous measurement.</p><p>First, we will have to parse the list of received measurements and transform it into an array of integers. To do this feel free to look</p>]]></description><link>https://triozer.github.io/aoc-2021-in-kotlin/blog/day-1/</link><guid isPermaLink="false">61a95c0754e62874979e3f05</guid><category><![CDATA[stdlib]]></category><dc:creator><![CDATA[Cédric Boirard]]></dc:creator><pubDate>Wed, 01 Dec 2021 22:59:00 GMT</pubDate><content:encoded><![CDATA[<h2 id="part-1"><a href="https://adventofcode.com/2021/day/1">Part 1</a></h2><h3 id="problem">Problem</h3><p>In this first part, we are talking about counting the number of times a depth measurement increases from the previous measurement.</p><p>First, we will have to parse the list of received measurements and transform it into an array of integers. To do this feel free to look at how it is done in the <code><a href="https://github.com/triozer/aoc-2021-in-kotlin/blob/7a8f7674983b3c07a8777bd274592a0ef5d1390b/src/main/kotlin/fr/triozer/aoc/Utils.kt#L15"><em>Utils.kt</em></a></code> file.</p><p>Then, we use the <code><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/zip-with-next.html">zipWithNext</a></code> function whose role is to pair the elements of our list. Let&apos;s take the example proposed for today:</p><pre><code>[199, 200, 208, ..., 269, 260, 263]</code></pre><p>After calling the function, we get:</p><pre><code>[
    [199, 200],
    [200, 208],
    ...
    [269, 260],
    [260, 263]
]</code></pre><p>Finally, we need to count how many of them match the criterion (a measure of depth increases from the previous measure) using the <code><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/count.html#count">count</a></code> function. The count function takes a predicate and if it returns true, the counter is incremented. In our case, we compare if the second element of the pair is greater than the first element of the pair.</p><h3 id="solution">Solution</h3><pre><code class="language-kt">fun part1(input: List&lt;Int&gt;) = input.zipWithNext().count {
    (next, previous) -&gt; next &gt; previous
}</code></pre><h2 id="part-2"><a href="https://adventofcode.com/2021/day/2">Part 2</a></h2><h3 id="problem-1">Problem</h3><p>The second part is really similar to the first one, except that instead of taking the values one by one, we group them by three.</p><p>For that, we can call the <code><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/windowed.html">windowed</a></code> function which create a sliding windowof a given size. Let&apos;s take the example proposed for today:</p><pre><code>[199, 200, 208, 210, ..., 240, 269, 260, 263]</code></pre><p>After calling the function, we get:</p><pre><code>[
    [199, 200, 208],
    [200, 208, 210],
    ...
    [240, 269, 260],
    [269, 260, 263]
]</code></pre><p>Now we want to sum each new list, fortunately Kotlin have a <code><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sum.html">sum</a></code> method that can called on iterators. So from the previous list, we now have:</p><pre><code>[
    607,
    618,
    ...
    769,
    792
]</code></pre><p>And that&apos;s awesome because we can reuse our previous function to count how many groups of measures increase from the previous group of measures.</p><h3 id="solution-1">Solution</h3><pre><code class="language-kt">fun part2(input: List&lt;Int&gt;) = part1(input.windowed(3) { it.sum() })</code></pre><h2 id="conclusion">Conclusion</h2><p>It was a great first puzzle! Besides being easy to understand, it reminded me how complete the standard Kotlin library was (in addition to being a great language).<br><br>+ 2 &#x2B50;&#xFE0F; !!!</p><h2 id="useful-links">Useful links</h2><ul><li><a href="https://triozer.github.io/aoc-2021-in-kotlin/introduction.html">Introduction</a> &#x2013; The introduction of this project.</li><li><a href="https://kotlinlang.org/">https://kotlinlang.org</a> &#x2013; Kotlin official website.</li><li><a href="https://github.com/triozer/aoc-2021-in-kotlin">https://github.com/triozer/aoc-2021-in-kotlin</a> &#x2013; My solutions and tests for each day.</li></ul><p><br></p>]]></content:encoded></item></channel></rss>